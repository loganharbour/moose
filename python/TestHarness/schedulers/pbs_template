#!/bin/bash
#PBS -N {{ NAME }}
#PBS -l select={{ SELECT }}
#PBS -l walltime={{ WALLTIME }}
#PBS -P {{ PROJECT }}
{%- if QUEUE is defined %}
#PBS -q {{ QUEUE }}
{%- endif %}
#PBS -j oe
#PBS -o {{ OUTPUT }}
#PBS -l place={{ PLACE }}

set -e

{%- if SOURCE_FILE is defined %}
# Loaded from {{ SOURCE_FILE }}
{{ SOURCE_CONTENTS }}
{%- endif %}

# Add MOOSE's python path for python scripts
export PYTHONPATH={{ MOOSE_PYTHONPATH }}:${PYTHONPATH}

# Print a useful header
echo "################################################################################"
echo "Beginning TestHarness RunPBS job"
echo "Submitted hostname: {{ SUBMITTED_HOSTNAME }}"
echo "Hostname: $(hostname)"
echo "Time: $(date)"
echo "Directory: {{ CWD }}"
echo "Output: {{ OUTPUT }}"
echo "Command: {{ COMMAND }}"
module list
echo "################################################################################"

# Move into the test directory
cd {{ CWD }}

set +e

# Run the command
{{ COMMAND }}
# ...and capture the return code cause we're not done yet
return_code=$?

set +e

# Append a terminator to all of the output files for file syncing across NFS
OUTPUT_FILES=({{ OUTPUT_FILES }})
for file in ${OUTPUT_FILES[@]}; do
    if [ ! -e "$file" ]; then
        echo "Failed to find output file $file"
        exit 1
    fi

    # No newline for binaries
    if [[ $(file --mime-encoding ${file}) = *binary ]]; then
        printf "{{ ENDING_COMMENT }}" >> $file;
    # Newline for plain text
    else
        printf "\n{{ ENDING_COMMENT }}" >> $file;
    fi
done

# Append a recognizable string at the end of the output. We look
# for this string when parsing the output so that we can be sure
# that we have obtained all of the output
echo "{{ ENDING_COMMENT }}"

# Exit with the real return code from the job that we ran
exit $return_code

