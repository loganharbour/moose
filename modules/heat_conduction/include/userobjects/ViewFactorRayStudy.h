//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include "RayTracingStudy.h"
#include "Ray.h"

class ViewFactorRayStudy : public RayTracingStudy
{
public:
  ViewFactorRayStudy(const InputParameters & parameters);

  static InputParameters validParams();

  /**
   * Data structure used for storing all of the information needed to spawn
   * Rays from a single element.
   */
  struct StartElem
  {
    StartElem(const Elem * elem,
              const unsigned short side,
              const Point & normal,
              const std::vector<Point> & points,
              const std::vector<Real> & weights)
      : _elem(elem), _side(side), _normal(normal), _points(points), _weights(weights)
    {
    }

    const Elem * _elem;
    const unsigned short int _side;
    const Point _normal;
    const std::vector<Point> _points;
    const std::vector<Real> _weights;
  };

  void initialSetup() override;

  /**
   * Adds into the view factor info; to be used in ViewFactorRayBC
   * @param value The value to add
   * @param from_id The from boundary
   * @param to_id The to boundary
   * @param tid The thread
   */
  void addToViewFactorInfo(Real value,
                           const BoundaryID from_id,
                           const BoundaryID to_id,
                           const THREAD_ID tid);

  /**
   * Accessor for the finalized view factor info
   * @param from_id The from boundary
   * @param to_id The to boundary
   */
  Real viewFactorInfo(const BoundaryID from_id, const BoundaryID to_id) const;

  /**
   * This is called before calling RayBCs on a Ray when it hits a boundary.
   *
   * Normally, this would include calling reinit at the intersection point on the boundary.
   * We override this here for optimization. Whenever a Ray generated by this study hits an
   * obstruction instead of its endpoint, we don't need any reinit at all. When a Ray does
   * hit its end point, all we need is the side normal. Therefore, we manage said normal
   * computation manually for optimization in ViewFactorRayBC and don't need to do
   * anything here.
   */
  void reinitBoundary(const Elem * /* elem */,
                      const unsigned short /* side */,
                      const Point & /* point */,
                      const BoundaryID /* bnd_id */,
                      const THREAD_ID /* tid */) override
  {
  }

  /**
   * This is called when a Ray crosses subdomains.
   *
   * With view factor computation, there is no depenence on subdomain. Therefore, we optimize
   * the trace by setting this to do nothing.
   */
  void subdomainSetup(SubdomainID /* subdomain */, THREAD_ID /* tid */, RayID /* ray_id */) override
  {
  }

  /**
   * This is called before the general work loop on a Ray segment.
   *
   * With view factor computation, there is no work to be done on a segment of a Ray. Therefore,
   * we optimize the trace by setting this to do nothing.
   */
  void reinitSegment(const Elem * /* elem */,
                     const Point & /* start */,
                     const Point & /* end */,
                     THREAD_ID /* tid */) override
  {
  }

  /**
   * This is called in RayStudyTraceRay to grab the RayBCs on a boundary.
   *
   * With view factor computation, we only have one RayBC. Therefore, cache it up front in
   * initialSetup() and return the cached object here.
   */
  void getRayBCs(std::vector<RayBC *> & result,
                 const std::vector<ConstBndElement> & /* bnd_elems */,
                 THREAD_ID tid,
                 RayID /* ray_id */) override
  {
    result = _threaded_cached_ray_bcs[tid];
  }

  /**
   * Casts the RayTracingStudy found in the given input parameters to a ViewFactorRayStudy with a
   * meaningful error message if it fails
   */
  static ViewFactorRayStudy & castFromStudy(const InputParameters & params);

protected:
  void generateRays() override;
  void generatePoints();

  void preExecuteStudy() override;
  void postExecuteStudy() override;

  /// The user supplied boundary IDs we need view factors on
  const std::vector<BoundaryID> _bnd_ids;

  /// Index in the Ray aux data for the starting boundary ID
  const RayDataIndex _ray_index_start_bnd_id;
  /// Index in the Ray aux data for the starting total weight (dot * qp weight)
  const RayDataIndex _ray_index_start_total_weight;
  /// Index in the Ray aux data for the ending boundary ID
  const RayDataIndex _ray_index_end_bnd_id;
  /// Index in the Ray aux data for the ending weight
  const RayDataIndex _ray_index_end_weight;
  /// Index in the Ray aux data for the distance from start to end
  const RayDataIndex _ray_index_start_end_distance;

private:
  /// Face FE used for creating face normals
  std::unique_ptr<FEBase> _fe_face;
  /// Face quadrature used for creating face normals
  std::unique_ptr<QBase> _q_face;

  /// The next available ID to assign to a Ray for this rank
  RayID _current_starting_id;
  /// The BoundaryIDs in _bnd_ids that are internal
  std::set<BoundaryID> _internal_bnd_ids;

  /// The objects that this proc needs to spawn Rays from (indexed by _bnd_ids)
  std::vector<std::vector<StartElem>> _start_info;
  /// The objects (point and weight) that this proc needs to spawn Rays to (indexed by _bnd_ids)
  std::vector<std::vector<std::pair<Point, Real>>> _end_points;

  /// View factor information by tid and then from/to pair
  std::vector<std::map<BoundaryID, std::map<BoundaryID, Real>>> _threaded_vf_info;
  /// Cumulative view factor information
  std::map<BoundaryID, std::map<BoundaryID, Real>> _vf_info;

  /// Used for caching the single RayBC per thread for use in getRayBCs()
  std::vector<std::vector<RayBC *>> _threaded_cached_ray_bcs;
};
