//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include "RayTracingStudy.h"
#include "Ray.h"

class ViewFactorRayStudy : public RayTracingStudy
{
public:
  ViewFactorRayStudy(const InputParameters & parameters);

  static InputParameters validParams();
  virtual void initialize() override;
  virtual void finalize() override;

  /**
   * Data structure used for storing all of the information needed to spawn
   * Rays from a single element.
   */
  struct StartElem
  {
    StartElem(const Elem * elem,
              const unsigned short side,
              const Point & normal,
              const std::vector<Point> & points,
              const std::vector<Real> & weights)
      : _elem(elem), _side(side), _normal(normal), _points(points), _weights(weights)
    {
    }

    const Elem * _elem;
    const unsigned short int _side;
    const Point _normal;
    const std::vector<Point> _points;
    const std::vector<Real> _weights;
  };

  // returns a writeable reference to _vf_info pair from_bnd_id -> to_bnd_id
  Real & viewFactorInfo(BoundaryID from_id, BoundaryID to_id, THREAD_ID tid);

  // const accessor into view factor info
  Real viewFactorInfo(BoundaryID from_id, BoundaryID to_id) const;

  /**
   * This is called before calling RayBCs on a Ray when it hits a boundary.
   *
   * Normally, this would include calling reinit at the intersection point on the boundary.
   * We override this here for optimization. Whenever a Ray generated by this study hits an
   * obstruction instead of its endpoint, we don't need any reinit at all. When a Ray does
   * hit its end point, all we need is the side normal. Therefore, we manage said normal
   * computation manually for optimization in ViewFactorRayBC and don't need to do
   * anything here.
   */
  virtual void reinitBoundary(const Elem * /* elem */,
                              const unsigned short /* side */,
                              const Point & /* point */,
                              const BoundaryID /* bnd_id */,
                              const THREAD_ID /* tid */) override
  {
  }

  /**
   * This is called when a Ray crosses subdomains.
   *
   * With view factor computation, there is no depenence on subdomain. Therefore, we optimize
   * the trace by setting this to do nothing.
   */
  virtual void
      subdomainSetup(SubdomainID /* subdomain */, THREAD_ID /* tid */, RayID /* ray_id */) override
  {
  }

  /**
   * This is called before the general work loop on a Ray segment.
   *
   * With view factor computation, there is no work to be done on a segment of a Ray. Therefore,
   * we optimize the trace by setting this to do nothing.
   */
  virtual void reinitSegment(const Elem * /* elem */,
                             const Point & /* start */,
                             const Point & /* end */,
                             THREAD_ID /* tid */) override
  {
  }

protected:
  virtual void generateRays() override;
  virtual void generatePoints();

  /// The user supplied boundary IDs we need view factors on
  const std::vector<BoundaryID> _bnd_ids;

  /// Index in the Ray aux data for the starting dot product
  const RayDataIndex _ray_index_start_dot;
  /// Index in the Ray aux data for the starting boundary ID
  const RayDataIndex _ray_index_start_bnd_id;
  /// Index in the Ray aux data for the starting weight
  const RayDataIndex _ray_index_start_weight;
  /// Index in the Ray aux data for the ending boundary ID
  const RayDataIndex _ray_index_end_bnd_id;
  /// Index in the Ray aux data for the ending weight
  const RayDataIndex _ray_index_end_weight;
  /// The x-index for the point on the boundary where this Ray should end
  const RayDataIndex _ray_index_end_x;
  /// The y-index for the point on the boundary where this Ray should end
  const RayDataIndex _ray_index_end_y;
  /// The z-index for the point on the boundary where this Ray should end
  const RayDataIndex _ray_index_end_z;

  /// Face FE used for creating face normals
  std::unique_ptr<FEBase> _fe_face;
  /// Face quadrature used for creating face normals
  std::unique_ptr<QBase> _q_face;

  /// The next available ID to assign to a Ray for this rank
  RayID _current_starting_id;

private:
  /// The objects that this proc needs to spawn Rays from (indexed by _bnd_ids)
  std::vector<std::vector<StartElem>> _start_info;
  /// The objects (point and weight) that this proc needs to spawn Rays to (indexed by _bnd_ids)
  std::vector<std::vector<std::pair<Point, Real>>> _end_points;

  /// view factor information by tid and then from/to pair
  std::vector<std::map<BoundaryID, std::map<BoundaryID, Real>>> _vf_info;
};
