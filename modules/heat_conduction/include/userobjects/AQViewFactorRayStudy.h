//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include "RayTracingStudy.h"

// libMesh includes
#include "libmesh/parallel.h"

// Forward declarations
class Ray;

class AQViewFactorRayStudy : public RayTracingStudy
{
public:
  AQViewFactorRayStudy(const InputParameters & parameters);

  static InputParameters validParams();
  static void getLegHRQ(unsigned int order, std::vector<Real> &x, std::vector<Real> &w);
  static void getLegChebHRQ(unsigned int cheb_order, unsigned int leg_order, std::vector<std::pair<Real, Real>> &x, std::vector<Real> &w);
  static Point getOrthonormalVector(const Point & v, unsigned int dim);

  void initialSetup() override;

  /**
   * This is called before calling RayBCs on a Ray when it hits a boundary.
   *
   * Normally, this would include calling reinit at the intersection point on the boundary.
   * We override this here for optimization. Whenever a Ray generated by this study hits an
   * obstruction instead of its endpoint, we don't need any reinit at all. When a Ray does
   * hit its end point, all we need is the side normal. Therefore, we manage said normal
   * computation manually for optimization in ViewFactorRayBC and don't need to do
   * anything here.
   */
  void reinitBoundary(
      const Elem *, const unsigned short, const Point &, const BoundaryID, const THREAD_ID) override
  {
  }

  /**
   * This is called when a Ray crosses subdomains.
   *
   * With view factor computation, there is no depenence on subdomain. Therefore, we optimize
   * the trace by setting this to do nothing.
   */
  void subdomainSetup(SubdomainID, THREAD_ID, RayID) override {}

  /**
   * This is called before the general work loop on a Ray segment.
   *
   * With view factor computation, there is no work to be done on a segment of a Ray. Therefore,
   * we optimize the trace by setting this to do nothing.
   */
  void reinitSegment(const Elem *, const Point &, const Point &, THREAD_ID) override {}

  /**
   * This is called in RayStudyTraceRay to grab the RayBCs on a boundary.
   *
   * With view factor computation, we only have one RayBC. Therefore, cache it up front in
   * initialSetup() and return the cached object here.
   */
  void getRayBCs(std::vector<RayBC *> & result,
                 const std::vector<ConstBndElement> &,
                 THREAD_ID tid,
                 RayID) override
  {
    result = _threaded_cached_ray_bcs[tid];
  }

  /**
   * Data structure used for storing all of the information needed to spawn
   * Rays from a single element.
   */
  struct StartElem
  {
    StartElem(const Elem * elem,
              const unsigned short int side,
              const Elem * start_elem,
              const unsigned short int start_side,
              const BoundaryID bnd_id,
              const Point & normal,
              const std::vector<Point> & points,
              const std::vector<Real> & weights)
      : _elem(elem),
        _side(side),
        _start_elem(start_elem),
        _start_side(start_side),
        _bnd_id(bnd_id),
        _normal(normal),
        _points(points),
        _weights(weights)
    {
    }

    const Elem * const _elem;
    const unsigned short int _side;
    const Elem * const _start_elem;
    const unsigned short int _start_side;
    const BoundaryID _bnd_id;
    const Point _normal;
    const std::vector<Point> _points;
    const std::vector<Real> _weights;
  };

  /**
   * Data structure used for storing all of the information needed to spawn Rays to a single element
   */
  struct EndElem
  {
    EndElem(const dof_id_type elem_id,
            const unsigned short int side,
            const BoundaryID bnd_id,
            const std::vector<Point> & points,
            const std::vector<Real> & weights)
      : _elem_id(elem_id), _side(side), _bnd_id(bnd_id), _points(points), _weights(weights)
    {
    }

    const dof_id_type _elem_id;
    const unsigned short int _side;
    const BoundaryID _bnd_id;
    const std::vector<Point> _points;
    const std::vector<Real> _weights;
  };

  /**
   * Adds into the view factor info; to be used in ViewFactorRayBC
   * @param value The value to add
   * @param from_id The from boundary
   * @param to_id The to boundary
   * @param tid The thread
   */
  void addToViewFactorInfo(Real value,
                           const BoundaryID from_id,
                           const BoundaryID to_id,
                           const THREAD_ID tid);

  /**
   * Accessor for the finalized view factor info
   * @param from_id The from boundary
   * @param to_id The to boundary
   */
  Real viewFactorInfo(const BoundaryID from_id, const BoundaryID to_id) const;

  /**
   * Get the MeshBase. Used in unpacking routines for StartElem.
   */
  const MeshBase & meshBase() const { return _mesh.getMesh(); }

  /**
   * Casts the RayTracingStudy found in the given input parameters to a AQViewFactorRayStudyBase with
   * a meaningful error message if it fails
   */
  static AQViewFactorRayStudy & castFromStudy(const InputParameters & params);

protected:
  void generateRays() override;
  void preExecuteStudy() override;
  void postExecuteStudy() override;

  /// The user supplied boundary IDs we need view factors on
  const std::vector<BoundaryID> _bnd_ids;

  /// The convention for spawning rays from internal sidesets
  const MooseEnum _internal_convention;

  /// Index in the Ray aux data for the starting boundary ID
  const RayDataIndex _ray_index_start_bnd_id;
  /// Index in the Ray aux data for the starting total weight (dot * qp weight)
  const RayDataIndex _ray_index_start_total_weight;

  /// the length scale of the spatial domain for setting ray end point
  Real _domain_length_scale;

private:
  void generatePoints();
  void generateRayIDs();
  DenseMatrix<Real> aqRoationMatrix(const Point & normal) const;
  Point getAngularDirection(unsigned int l) const;

  /// Face FE used for creating face normals
  std::unique_ptr<FEBase> _fe_face;
  /// Face quadrature used for creating face normals
  std::unique_ptr<QBase> _q_face;

  /// View factor information by tid and then from/to pair
  std::vector<std::map<BoundaryID, std::map<BoundaryID, Real>>> _threaded_vf_info;
  /// Cumulative view factor information
  std::map<BoundaryID, std::map<BoundaryID, Real>> _vf_info;

  /// Used for caching the single RayBC per thread for use in getRayBCs()
  std::vector<std::vector<RayBC *>> _threaded_cached_ray_bcs;

  /// The next available ID to assign to a Ray for this rank
  RayID _current_starting_id;
  /// The BoundaryIDs in _bnd_ids that are internal
  std::set<BoundaryID> _internal_bnd_ids;

  /// The objects that this proc needs to spawn Rays from (indexed by _bnd_ids)
  std::vector<StartElem> _start_info;

  ///@{ angular quadrature info
  std::vector<std::pair<Real, Real>> _aq_angles;
  std::vector<Real> _aq_weights;
  unsigned int _naq;
  ///@}

  /// the rotation matrix to obtain direction for a given normal vector
  DenseMatrix<Real> _rotation_matrix;
};

namespace libMesh
{
namespace Parallel
{
template <>
class Packing<AQViewFactorRayStudy::StartElem *>
{
public:
  typedef Real buffer_type;

  static unsigned int packed_size(typename std::vector<Real>::const_iterator in);

  static unsigned int packable_size(const AQViewFactorRayStudy::StartElem * const start_elem,
                                    const void *);

  template <typename Iter, typename Context>
  static void
  pack(const AQViewFactorRayStudy::StartElem * const object, Iter data_out, const Context *);

  template <typename BufferIter, typename Context>
  static AQViewFactorRayStudy::StartElem * unpack(BufferIter in, Context *);
};

} // namespace Parallel

} // namespace libMesh
